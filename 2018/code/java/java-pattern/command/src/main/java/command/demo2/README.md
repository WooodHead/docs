# Receiver: 接收者
 
	它知道如何处理具体的业务逻辑。

# Comand: 抽象命令

	它定义了 一 个命令对象 应具备的 一系列命令操作， 比如execute()、 undo()、 redo()等。 
	当命令操作被调用的时候就会触发接收者去做具体命令对应的业务逻辑。
	
# ConcreteComand: 具体的命令实现

    在这里它绑定了命令操作与接收者之间的关系， execute()命令的实现委托给了 Receiver的 action()函数。
    
# Invoker: 调用者

     它持有 一个命令对象， 并且可以在需要的时候通过命令对象完成具体的业务逻辑。

	
# 说明
	
	调用者Invoker与操作者Receiver通过 Comand命令接口实现了解耦。对于调用者来说， 我们可以为其注入多个
	命令操作， 比如新建文件、复制文件、 删除文件这样三个操作， 调用者只需在需要的时候直接调用即可， 
	而不需要知道 这些操作命令实际是如何实现的 。
	
	Invoker和Receiver的关系非常类似于 “请求－响应” 模式， 所以它比较适用于实现记录日志、 撤销操作、
	队列请求等。
	
# 场景

    在下面这些情况下应考虑使用命令模式。

	• 使用命令模式作为 “ 回调CCallBack) "在面向对象系统中的替代。"CallBack"讲的便是先将 一个函数登记
	上， 然后在以后调用此函数。

	• 需要在不同的时间指定请求、 将请求排队。 一个命令对象和原先的请求发出者可以有不同的生命期。 换言
	之， 原先的请求发出者可能已经不在了， 而命令对象本身仍然是活动的。这时命令的接收者可以是在本地，
	也可以在网络的另外 一个地址。命令对象可以在序列化之后传送到另外 一 台机器上去。
	
	• 系统需要支持命令的撤销。命令对象可以把状态存储起来，等到客户端需要撤销命令所产生的效果时， 可以
	调用undo()方法， 把命令所产生的效果撤销掉。命令对象还可以提供redo()方法， 以供客户端在需要时再重
	新实施命令效果
	
	• 如果要将系统中所有的数据更新到日志里，以便在系统 崩溃时，可以根据日志读回所有的数据更新命令， 
	重新 调用 Execute()方法 一条 一条执行 这些命令， 从而恢复系统在崩溃前所做的数据更新。

	
# 执行
	
	• execute(): 同步执行，从依赖的服务 返回 一个单 一的结果对象， 或是在发生错误
	的时候抛出异常。

	• queue(): 异步执行， 直接返回 一个Future对象， 其中包含了服务 执行 结束时要
	返回的单一结果对象。
	
	• observe(): 返回Observable对象，它代表了操作的多个结果，它是 一个HotObserable。
	
    • toObservable(): 同样会返回Observable对象， 也代表了操作的多个结果，

	
	